"""Mock implementations of dependencies for example script."""

from typing import Dict, Any, Optional
from uuid import UUID

from mrbob.reports.application.report_service import (
    ReportRepository,
    EventPublisher,
    TemplateEngine,
    UnitOfWork,
    Report
)


class MockReportRepository(ReportRepository):
    """Mock implementation of report repository."""
    
    def __init__(self):
        """Initialize with empty storage."""
        self._reports = {}
    
    async def save(self, report: Report) -> None:
        """Save report to in-memory storage."""
        self._reports[report.id] = report
    
    async def get(self, report_id: UUID) -> Optional[Report]:
        """Get report from in-memory storage."""
        return self._reports.get(report_id)
    
    async def get_by_metadata(
        self,
        report_type: Optional[str] = None,
        generated_by: Optional[str] = None
    ) -> list[Report]:
        """Query reports by metadata."""
        reports = []
        for report in self._reports.values():
            if (report_type is None or 
                report.metadata.report_type == report_type):
                if (generated_by is None or 
                    report.metadata.generated_by == generated_by):
                    reports.append(report)
        return reports


class MockEventPublisher(EventPublisher):
    """Mock implementation of event publisher."""
    
    async def publish(self, event: Dict[str, Any]) -> None:
        """Mock publish operation."""
        pass


class MockTemplateEngine(TemplateEngine):
    """Mock implementation of template engine."""
    
    async def render(
        self,
        template_name: str,
        context: Dict[str, Any],
        output_path: str
    ) -> None:
        """Generate a viewable HTML report."""
        # Change output path from .pdf to .html
        output_path = output_path.replace('.pdf', '.html')
        
        # Generate HTML content
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Agent Performance Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                h1, h2 {{ color: #333; }}
                .section {{ margin: 20px 0; padding: 20px; border: 1px solid #ddd; }}
                .metric {{ margin: 10px 0; }}
                .metric-label {{ font-weight: bold; }}
                table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
                th, td {{ padding: 8px; text-align: left; border: 1px solid #ddd; }}
                th {{ background-color: #f5f5f5; }}
            </style>
        </head>
        <body>
            <h1>Agent Performance Report</h1>
            
            <div class="section">
                <h2>Report Metadata</h2>
                <div class="metric">
                    <span class="metric-label">Generated At:</span> {context['metadata'].generated_at}
                </div>
                <div class="metric">
                    <span class="metric-label">Generated By:</span> {context['metadata'].generated_by}
                </div>
                <div class="metric">
                    <span class="metric-label">Report Type:</span> {context['metadata'].report_type.value}
                </div>
            </div>
            
            <div class="section">
                <h2>Performance Metrics</h2>
                {self._render_metrics_table(context)}
            </div>
            
            <div class="section">
                <h2>Policy Details</h2>
                {self._render_policies_table(context)}
            </div>
        </body>
        </html>
        """
        
        # Write HTML file
        with open(output_path, 'w') as f:
            f.write(html_content)
    
    def _render_metrics_table(self, context: Dict[str, Any]) -> str:
        """Render metrics as an HTML table."""
        if not context.get('sections'):
            return "<p>No metrics available</p>"
        
        metrics_html = []
        for section in context['sections']:
            if isinstance(section.content, dict):
                metrics_html.append("<table>")
                metrics_html.append("<tr><th>Metric</th><th>Value</th></tr>")
                
                for key, value in section.content.items():
                    if isinstance(value, dict):
                        for subkey, subvalue in value.items():
                            metrics_html.append(
                                f"<tr><td>{key} - {subkey}</td>"
                                f"<td>{subvalue}</td></tr>"
                            )
                    else:
                        metrics_html.append(
                            f"<tr><td>{key}</td><td>{value}</td></tr>"
                        )
                
                metrics_html.append("</table>")
        
        return "\n".join(metrics_html)
    
    def _render_policies_table(self, context: Dict[str, Any]) -> str:
        """Render policies as an HTML table."""
        if not context.get('sections'):
            return "<p>No policy data available</p>"
        
        policies_html = ["<table>", "<tr>"]
        headers = set()
        
        # Collect all possible headers from all policies
        for section in context['sections']:
            if isinstance(section.content, dict):
                for key in section.content.keys():
                    headers.add(key)
        
        # Add headers
        for header in sorted(headers):
            policies_html.append(f"<th>{header}</th>")
        policies_html.append("</tr>")
        
        # Add policy data
        for section in context['sections']:
            if isinstance(section.content, dict):
                policies_html.append("<tr>")
                for header in sorted(headers):
                    value = section.content.get(header, '')
                    policies_html.append(f"<td>{value}</td>")
                policies_html.append("</tr>")
        
        policies_html.append("</table>")
        return "\n".join(policies_html)


class MockUnitOfWork(UnitOfWork):
    """Mock implementation of unit of work."""
    
    async def __aenter__(self) -> 'MockUnitOfWork':
        """Enter context."""
        return self
    
    async def __aexit__(self, exc_type, exc, tb) -> None:
        """Exit context."""
        pass
    
    async def commit(self) -> None:
        """Mock commit operation."""
        pass
    
    async def rollback(self) -> None:
        """Mock rollback operation."""
        pass
